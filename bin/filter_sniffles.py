#!/usr/bin/env python3


# From a VCF of SVs generated by manta, filter out SVs:
# - whose length is too short
# - which have insufficient Read Pair or Split Reads support
# - (optionally) for which one breakend is in a region present in the Panel of Normal
# - short insertions which likely correspond to retrotransposons (except when they are in the vicinity of a gene). This filtering requires 2 breakpoints.
# (optionally) flags SVs for which one breakend is close to a low mappability region
# (optionally) checks that deletions/duplications are supported by the coverage

import os
import argparse
import numpy as np
import vcfpy
import pysam

parser = argparse.ArgumentParser()
parser.add_argument('-i', type = str, help='VCF generated by manta')
parser.add_argument('-o', type = str, help='Output VCF')
parser.add_argument('--pon', type = str, help='bed file containing regions to filter out.')
parser.add_argument('--minSR', type = int,default=0, help='Minimum number of split reads supporting the SV') #DV: number of variant reads; DR: number of reference reads.
parser.add_argument('--minLen', type = int,default=20000, help='Minimum SV length')
parser.add_argument('--bam', type = str, help='BAM file (used to check the breakpoints')
parser.add_argument('--mappability', type = str, help='bed file containing the regions with low mappability')
parser.add_argument('--cnv', type = str, help='cnv file produced by control freec. Less stringent filters are used for SVs close to CNA borders.')
parser.add_argument('--tumorindex', type = int,default=0, help='Index of the tumor sample (0 if only the tumor sample was provided, 1 if a control was used).')
parser.add_argument('--keepCloseSV', type = int,default=0, help='If set to 1, will not filter out two SVs whose breakpoints are close to each other (could be reciprocal translocation)')
parser.add_argument('--filterSmallInsertions', type = int,default=1, help='If set to 0, will not filter out SVs resulting in small insertions.')
parser.add_argument('--puretumor', type = int,default=0, help='If set to 1, will assume that the tumor is pure and will not filter out when no reads support the reference allele..')
args = parser.parse_args()


#sample = "C010-AML-15PB8708"
#args.i = "/home/e840r/Documents/WGS/SVs/manta/filtered/"+sample+".vcf"
#args.o = "/home/e840r/Documents/WGS/SVs/manta/filtered_PoN/"+sample+".vcf"
#args.f= "/home/e840r/Documents/WGS/healthy/SV/PoN_SV.bed"

window_size = 3000 # for filtering out small insertions. 

chromosomes = [str(x) for x in range(1,23)] + ["chr"+str(x) for x in range(1,23)] + ["X","Y","chrX","chrY"]

def locus_in_bedRegion(file,chr,pos):
    """
    Parse the bed files of filtered regions to see if one position is present in one of these regions.
    Start from the last position, to avoid iterating several times through the file (the files are assumed to be sorted)
    """
    current_chr = "0"
    start = 0
    end=0
    line = True
    #print("------ Looking for "+chr+"_"+str(pos))
  
    last_pos_file = file.tell()
    pos_file = file.tell()
    while line and current_chr!=chr: # get to the right chromosome
        #print(line)
        last_pos_file = file.tell()
        pos_file = file.tell()
        line = file.readline()
        if line:
            linesplit = line.split("\t")
            current_chr = linesplit[0]
            start = int(linesplit[1])
            end = int(linesplit[2])
  
    while line and current_chr==chr and end<pos:
        last_pos_file = pos_file
        pos_file = file.tell()
        line = file.readline()
        if line:
            linesplit = line.split("\t")
            current_chr = linesplit[0]
            start = int(linesplit[1])
            end = int(linesplit[2])
    file.seek(last_pos_file) # go back one line 

    if pos <= end and pos >= start:
        return True
    else:
        return False



# Get all of the positions of the breakends
positions = set()
reader = vcfpy.Reader.from_path(args.i)
for record in reader:
    chr = record.CHROM
    pos = record.POS
    positions.add((chr,pos))
    if record.INFO["SVTYPE"][:3] in ["DEL","DUP","INS","INV"]:
        chr2 = chr
        pos2 = record.INFO["END"]
    else:
        chr2 = record.ALT[0].mate_chrom
        pos2 = record.ALT[0].mate_pos
    positions.add((chr2,pos2))

def sort_chr_pos(t):
    chr = t[0]
    pos = t[1]
    if chr.isdigit(): chr = int(chr)
    else:
        if chr=="X": chr = 23
        else: chr=24
    return chr * 400000000 + pos

positions = sorted(list(positions), key = sort_chr_pos)

# Go through the PoN file to see which of the breakends are filtered out
pos_is_filtered={}
if args.pon is not None:
    print("PoN was provided")
    file_filter = open(args.pon,"r")
    for pos in positions:
        pos_is_filtered[pos] = locus_in_bedRegion(file_filter,pos[0],pos[1])
    file_filter.close()
else:
    print("PoN was not provided")
    for pos in positions:
        pos_is_filtered[pos] = False



def get_breakpoint_info(record):
    chr = record.CHROM
    pos = record.POS
    if record.INFO["SVTYPE"] in ["DEL","DUP","INS","INV"]:
        chr2 = chr
        pos2 = record.INFO["END"]
        if record.INFO["SVTYPE"]=="DEL":
            orientation = "-"
            orientation2 = "+"
        elif record.INFO["SVTYPE"]=="DUP":
            orientation = "+"
            orientation2 = "-"
        else:
            orientation = "-"
            orientation2 = "+"
    else:
        chr2 = record.ALT[0].mate_chrom
        pos2 = record.ALT[0].mate_pos
        orientation = record.ALT[0].orientation
        orientation2 = record.ALT[0].mate_orientation
    return ( (chr,pos,orientation) , (chr2,pos2,orientation2) )

#########################
## Write the filtered VCF
reader = vcfpy.Reader.from_path(args.i)
header = reader.header
#header.add_filter_line({"ID":"MAPPABILITY","Description":"Regions with low mappability close to the breakpoint."})
writer = vcfpy.Writer.from_path(args.o,reader.header)
for record in reader:
    print("-----------")
    print(record)
    ( (chr,pos,orientation) , (chr2,pos2,orientation2) ) = get_breakpoint_info(record)
    if (not chr in chromosomes) or (not chr2 in chromosomes):
        print("Filtered out because of unknown chromosomes")
        continue

   
    # Filter based on minimum number of supporting reads
    if (not "DV" in record.calls[args.tumorindex].data):
        filtered_n_reads=True
    else:
        filtered_n_reads = (record.calls[args.tumorindex].data["DV"] < args.minSR)
        # Somatic SVs (and heterozygous): expect some reads which do not support the SV.
        if args.puretumor==0:
            filtered_n_reads = filtered_n_reads or (record.calls[args.tumorindex].data["DR"] < 2)
    if filtered_n_reads:
        print("SV filtered due to insufficient number of supporting reads")
        continue

    # Filter based on minimum SV length
    filtered_length = (chr==chr2) and ( abs(pos-pos2) < args.minLen)
    if filtered_length:
        print("SV filtered due to short length")
        continue
    # Filter based on Panel of Normal
    one_breakend_filtered = pos_is_filtered[(chr,pos)] or pos_is_filtered[(chr2,pos2)]
    if one_breakend_filtered:
        print("SV filtered by Panel of Normal")
        continue

    print("Keep SV")
    writer.write_record(record)